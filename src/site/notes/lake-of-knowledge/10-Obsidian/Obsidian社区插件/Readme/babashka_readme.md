---
{"uid":2023080322145144,"title":"Obsidian 插件：Babashka","tags":["obsidian插件","readme"],"description":"在Babashka中评估Clojure(Script)代码块。","author":"AI","type":"readme","draft":false,"editable":false,"modified":20230101000000,"dg-publish":true,"permalink":"/lake-of-knowledge/10-obsidian/obsidian/readme/babashka-readme/","dgPassFrontmatter":true}
---


# Obsidian 插件：Babashka

> [!Note] 插件名片
> - 插件名称：Babashka
> - 插件作者：Filipe Silva
> - 插件说明：在 Babashka 中评估 Clojure(Script) 代码块。
> - 插件分类：['obsidian 插件 ', 'readme']
> - 项目地址：[点我访问](https://github.com/filipesilva/obsidian-babashka)
> - 国内下载地址：[下载安装](https://pkmer.cn/products/plugin/pluginMarket/?babashka)

## 概述

在 Babashka 中评估 Clojure(Script) 代码块。

![Babashka](https://cdn.pkmer.cn/covers/babashka.gif!pkmer)

> [!tip] 原文出处
>
>下面自述文件的来源于 [Readme](https://ghproxy.net/https://raw.githubusercontent.com/filipesilva/obsidian-babashka/master/README.md)
>

---

## Readme(翻译）

下面是 [[babashka\|babashka]] 插件的自述翻译

Obsidian Babashka 是 Obsidian 的插件，通过 Babashka 和 Node Babashka 分别运行 Clojure 和 ClojureScript 代码块。

这个插件的主要用途是在您的 vault 文档上下文中进行脚本编写。

## 先决条件

在评估 `clojure` 代码块时，您需要安装 [Babashka](https://github.com/babashka/babashka#installation) ，并且在评估 `clojurescript` 代码块时，您需要安装 [Node](https://nodejs.org/en/download/) 和 [Node Babashka](https://github.com/babashka/nbb#usage) 。

在评估代码块之前，您需要在插件设置中设置 `bb` 的绝对路径（用于 clojure），以及 `node` 和 `nbb` 的绝对路径（用于 clojurescript）。

您可以使用终端中的 `where` 命令找到这些路径。

如果您具有 Clojure 的背景，但对 Babashka 不熟悉，请记住 Babashka 与 Clojure 有所不同，并且还包含了 Clojure 中没有的库。

请查阅 Babashka 和 Node Babashka 文档，了解更多可用的内容。

## 特点

### 评估 Clojure 和 ClojureScript 代码块

![eval-codeblock](./docs/eval-codeblock.gif)

### 在外部评估代码块并打印值

![eval-codeblock-and-print-outside](./docs/eval-codeblock-and-print-outside.gif)

### 启动并连接到 Babashka nREPL 服务器

![async](./docs/nrepl.gif)

### 当前文件的 Vault 绑定

![vault-bindings](./docs/vault-bindings.jpg)

如果你想要复制粘贴代码，这里是代码：

```clojure
(require '[vault-bindings :as vb])

[vb/*vault-name*
 vb/*vault-path*
 vb/*vault-babashka-path*
 vb/*last-folder-path*
 vb/*last-file-name*
 vb/*last-file-path*
 vb/*vault-plugin-folder*]
```

由于 Babashka 非常强大，因此在 clj 和 cljs 中都支持阻塞异步。

### 杀死所有的 eval 和 nREPL 进程

使用 `Babashka: Kill all Babashka processes` 命令来杀死所有的 eval 和 nREPL 进程以及它们的客户端。

通过 `bb.edn` 和 `nbb.edn` 进行依赖项配置

你可以在 vault babashka 目录中找到 [`bb.edn`](https://book.babashka.org/#project-setup) 和 [`nbb.edn`](https://github.com/babashka/nbb#dependencies)。它默认为 `.babashka`，但可以在设置中进行配置。

你可以配置源路径，并将依赖项添加到这些文件中，这些依赖项将在代码块中可用。

在此目录中安装的 NPM 包也将对 CLJS 代码块可用。

如果你正在同步 vault 并安装大量依赖项，你可能希望将 vault babashka 目录设置为 vault 之外的绝对路径，以便不同步依赖项。

## 工作原理

当您调用 eval 命令时，插件将会：

- 使用正则表达式在文件中查找所有的代码块
- 如果您不在一个 Clojure 或 ClojureScript 代码块中，会通过通知告知您，并停止执行
- 将您的代码发送到 REPL，如果有的话，或者使用 `bb -e "..."` 调用您的代码，其中 `"` 被转义，并将当前工作目录设置为 vault babashka 目录
- 如果您已经打开了该设置，将输出限制在 1000 行以内
- 将输出作为注释打印在代码块内部，或者作为纯文本打印在外部，取决于您运行的 eval 命令以及开发者控制台（在 Mac 上为 cmd+opt+i，就像 Chrome 一样）
- eval 错误和 stderr 显示为通知，并在开发者控制台中显示

消息以调试级别打印到开发者控制台，因此您需要在开发者控制台设置中打开详细日志级别才能看到它们。

它们还以 `[obsidian-babashka]` 为前缀，以便您可以将它们过滤掉。

当您调用 repl 命令时，插件将会：

- 在设置的端口上生成一个新的 Babashka nREPL 服务器进程
- 等待直到看到字符串 `nREPL`
- 连接到 nREPL 客户端
- 显示连接成功的通知
- 在状态栏上显示活动的客户端
- 设置处理程序以在错误或关闭时删除进程和客户端
- 在卸载插件时杀死所有进程

当您调用 kill processes 命令时，插件将会：

- 显示要杀死的进程数量的通知
- 向所有 eval 和 nREPL 进程发送 kill 调用
- 断开并销毁所有 nREPL 客户端

`vault-bindings` 命名空间位于 `.babashka/gen/vault-bindings.cljc` 中，并且每次您 eval 一个代码块时都会自动生成：

```clojure
(ns vault-bindings)
;; This file is auto-generated by the Babashka plugin when you eval a codeblock.
;; Don't edit it directly, it will be overwritten.
(def *vault-name* "personal")
(def *vault-path* "/Users/filipesilva/Library/Mobile Documents/iCloud~md~obsidian/Documents/personal")
(def *vault-babashka-path* "/Users/filipesilva/Library/Mobile Documents/iCloud~md~obsidian/Documents/personal/.babashka")
(def *last-folder-path* "/Users/filipesilva/Library/Mobile Documents/iCloud~md~obsidian/Documents/personal//")
(def *last-file-name* "scratch.md")
(def *last-file-path* "/Users/filipesilva/Library/Mobile Documents/iCloud~md~obsidian/Documents/personal/scratch.md")
```

## 路线图

我想保存一些代码块以便与快捷方式一起使用。

这样，您可以在不同的上下文中运行该代码，并且甚至可以使用文本选择作为输入。

我想象文本选择将被添加到*vault-bindings*中。

启动一个具有访问编辑器命令绑定的进程内 nbb repl 听起来很有趣。

这可能有助于调试，也有助于编写与编辑器交互的代码。

但这也可能是个坏主意，因为它只能通过终止编辑器进程来强制终止。

## 先前技术

- <https://github.com/victorb/obsidian-wielder>
- <https://github.com/twibiral/obsidian-execute-code>

开发指南

### 如何在本地运行插件

- 克隆这个仓库。
- 要么克隆到插件文件夹中，要么在那里创建符号链接，例如 `ln -s /path/to/obsidian-babashka /path/to/your/vault/.obsidian/plugins/obsidian-babashka`。
- 运行 `npm i` 或 `yarn` 安装依赖。
- 运行 `npm run dev` 以启动编译并进入监视模式。
- 重新加载 Obsidian 以初始化加载插件。
- 在社区插件中禁用/启用插件以在进行更改后重新加载插件。

### 发布新版本

- 在你的 `manifest.json` 文件中更新最新版本所需的 Obsidian 最低版本。
- 运行 `yarn version` 命令，并输入新的版本号。
- 使用新的版本号作为“标签版本”创建新的 GitHub 发布。在发布名称中使用完整的版本号，不要包含前缀 `v`。参考这里的示例：<https://github.com/obsidianmd/obsidian-sample-plugin/releases>
- 将 `manifest.json`、`main.js` 和 `styles.css` 文件作为二进制附件上传。注意：`manifest.json` 文件必须同时存在于仓库的根路径和发布中。
- 发布该版本。

将您的插件添加到社区插件列表中

- 检查 <https://github.com/obsidianmd/obsidian-releases/blob/master/plugin-review.md>
- 发布一个初始版本。
- 确保您的存储库的根目录中有一个 `README.md` 文件。
- 在 <https://github.com/obsidianmd/obsidian-releases> 上发起一个拉取请求，以添加您的插件。

API 文档

请参阅<https://github.com/obsidianmd/obsidian-api>
